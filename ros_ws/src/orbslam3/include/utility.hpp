#ifndef __UTILITY_HPP__
#define __UTILITY_HPP__

#include <iostream>
#include <algorithm>
#include <fstream>
#include <chrono>
#include <vector>
#include <queue>
#include <thread>
#include <mutex>

// Eigen
#include <Eigen/Dense>
#include <Eigen/Core>

// OpenCv
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/core/eigen.hpp>

#include <cv_bridge/cv_bridge.h>

#include <rclcpp/rclcpp.hpp>
// #include <rclcpp/time.hpp>

#include <tf2_ros/transform_broadcaster.h>
#include "tf2/LinearMath/Transform.h" // [Info] Extra generated by Gemini
// #include "tf2_geometry_msgs/tf2_geometry_msgs.h" // [Info] Extra generated by Gemini. For converting tf2::Transform to geometry_msgs::msg::TransformStamped

#include "geometry_msgs/msg/transform.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include <std_msgs/msg/header.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include "nav_msgs/msg/odometry.hpp"
#include "sensor_msgs/msg/image.hpp"
#include "image_transport/image_transport.hpp"
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <visualization_msgs/msg/marker.hpp>
// #include "visualization_msgs/msg/marker_array.hpp" // [Info] Extra generated by Gemini
// #include "builtin_interfaces/msg/time.hpp" // For Utility::StampToSec


#include "message_filters/subscriber.h"
#include "message_filters/synchronizer.h"
#include "message_filters/sync_policies/approximate_time.h"

#include "envision_interfaces/srv/save_map.hpp"

// //#include <orbslam3/srv/save_map.hpp> // Adjusted for ROS 2 service; assumes package name 'orbslam3'

// ORB-SLAM3 Specific libraries
#include "System.h"
#include "ImuTypes.h"
#include "Frame.h"
#include "Map.h"
#include "Tracking.h"

class Utility
{
public:
  static double StampToSec(builtin_interfaces::msg::Time stamp)
  {
    double seconds = stamp.sec + (stamp.nanosec * pow(10, -9));
    return seconds;
  }
};

// // ORB-SLAM3 global variables
extern ORB_SLAM3::System* pSLAM;
extern ORB_SLAM3::System::eSensor sensor_type;

extern std::string world_frame_id, cam_frame_id, imu_frame_id;
extern rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_pub;
extern rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr tracked_mappoints_pub;
extern rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr tracked_keypoints_pub;
extern rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr all_mappoints_pub;
extern rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr kf_markers_pub;
extern rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr odom_pub;
extern image_transport::Publisher tracking_img_pub;


// // Function declarations (updated for ROS 2)
void setup_services(std::shared_ptr<rclcpp::Node> node, const std::string &node_name);
void setup_publishers(std::shared_ptr<rclcpp::Node> node, image_transport::ImageTransport &image_transport,const std::string &node_name);

void publish_topics(const rclcpp::Time &msg_time, const Eigen::Vector3f &Wbb);

void publish_camera_pose(const Sophus::SE3f &Tcw_SE3f, const rclcpp::Time &msg_time);
void publish_tracking_img(cv::Mat image, rclcpp::Time msg_time);
void publish_tracked_points(std::vector<ORB_SLAM3::MapPoint*> tracked_points, rclcpp::Time msg_time);
void publish_keypoints(std::vector<ORB_SLAM3::MapPoint*> tracked_map_points, std::vector<cv::KeyPoint> tracked_keypoints, rclcpp::Time msg_time);

void publish_all_points(std::vector<ORB_SLAM3::MapPoint*> map_points, rclcpp::Time msg_time);
void publish_tf_transform(Sophus::SE3f T_SE3f, std::string frame_id, std::string child_frame_id, rclcpp::Time msg_time);
void publish_body_odom(const Sophus::SE3f &Twb_SE3f,const Eigen::Vector3f &Vwb_E3f,const Eigen::Vector3f &ang_vel_body,const rclcpp::Time &msg_time);
void publish_kf_markers(std::vector<Sophus::SE3f> vKFposes, rclcpp::Time msg_time);

bool save_map_srv(const std::shared_ptr<envision_interfaces::srv::SaveMap::Request> req, 
    std::shared_ptr<envision_interfaces::srv::SaveMap::Response> res);
bool save_traj_srv(const std::shared_ptr<envision_interfaces::srv::SaveMap::Request> req, 
    std::shared_ptr<envision_interfaces::srv::SaveMap::Response> res);


cv::Mat SE3f_to_cvMat(Sophus::SE3f T_SE3f);
geometry_msgs::msg::Transform SE3f_to_transform_msg(const Sophus::SE3f &T_SE3f);
sensor_msgs::msg::PointCloud2 keypoints_to_pointcloud(const std::vector<cv::KeyPoint>& keypoints, rclcpp::Time msg_time);
sensor_msgs::msg::PointCloud2 mappoint_to_pointcloud(const std::vector<ORB_SLAM3::MapPoint*>& map_points, rclcpp::Time msg_time);

#endif