#ifndef __UTILITY_HPP__
#define __UTILITY_HPP__

// #include <iostream>
// #include <algorithm>
// #include <fstream>
// #include <chrono>
// #include <vector>
// #include <queue>
// #include <thread>
// #include <mutex>

// // Eigen
// #include <Eigen/Dense>
// #include <Eigen/Core>

// // OpenCv
// #include <opencv2/opencv.hpp>
// #include <opencv2/core/core.hpp>
// #include <opencv2/core/eigen.hpp>

#include <cv_bridge/cv_bridge.h>

#include <rclcpp/rclcpp.hpp>
// #include <rclcpp/time.hpp>

// #include <image_transport/image_transport.h> 
// #include <tf2_ros/transform_broadcaster.h>
// #include "tf2/LinearMath/Transform.h" // [Info] Extra generated by Gemini
// #include "tf2_geometry_msgs/tf2_geometry_msgs.h" // [Info] Extra generated by Gemini. For converting tf2::Transform to geometry_msgs::msg::TransformStamped

// #include "geometry_msgs/msg/pose_stamped.hpp"
// #include <std_msgs/msg/header.hpp>
// #include <sensor_msgs/msg/imu.hpp>
// #include <nav_msgs/msg/odometry.hpp>
// #include "nav_msgs/msg/odometry.hpp"
#include "sensor_msgs/msg/image.hpp"
// #include <sensor_msgs/msg/point_cloud2.hpp>
// #include <visualization_msgs/msg/marker.hpp>
// #include "visualization_msgs/msg/marker_array.hpp" // [Info] Extra generated by Gemini
// #include "builtin_interfaces/msg/time.hpp" // For Utility::StampToSec


#include "message_filters/subscriber.h"
#include "message_filters/synchronizer.h"
#include "message_filters/sync_policies/approximate_time.h"

#include "envision_interfaces/srv/save_map.hpp"

// //#include <orbslam3/srv/save_map.hpp> // Adjusted for ROS 2 service; assumes package name 'orbslam3'

// ORB-SLAM3 Specific libraries
#include "System.h"
#include "ImuTypes.h"
#include "Frame.h"
#include "Map.h"
#include "Tracking.h"

class Utility
{
public:
  static double StampToSec(builtin_interfaces::msg::Time stamp)
  {
    double seconds = stamp.sec + (stamp.nanosec * pow(10, -9));
    return seconds;
  }
};

// // ORB-SLAM3 global variables
// extern ORB_SLAM3::System* pSLAM;
// extern ORB_SLAM3::System::eSensor sensor_type;

// extern std::string world_frame_id, cam_frame_id, imu_frame_id;

// // Update publishers for ROS 2
// extern rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr pose_pub, odom_pub;
// extern rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr kf_markers_pub;
// extern rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr tracked_mappoints_pub, all_mappoints_pub;
// // For image publishing in ROS 2, use sensor_msgs/msg/Image with rclcpp publisher
// extern rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr tracking_img_pub;

// // Function declarations (updated for ROS 2)
// void setup_services(rclcpp::Node::SharedPtr, std::string);
// void setup_publishers(rclcpp::Node::SharedPtr, std::string); // Removed image_transport; use rclcpp publisher
// void publish_topics(rclcpp::Time, Eigen::Vector3f = Eigen::Vector3f::Zero());

// void publish_camera_pose(Sophus::SE3f, rclcpp::Time);
// void publish_tracking_img(cv::Mat, rclcpp::Time);
// void publish_tracked_points(std::vector<ORB_SLAM3::MapPoint*>, rclcpp::Time);
// void publish_keypoints(std::vector<ORB_SLAM3::MapPoint*>, std::vector<cv::KeyPoint>, rclcpp::Time);
// sensor_msgs::msg::PointCloud2 keypoints_to_pointcloud(std::vector<cv::KeyPoint>&, rclcpp::Time);

// void publish_all_points(std::vector<ORB_SLAM3::MapPoint*>, rclcpp::Time);
// void publish_tf_transform(Sophus::SE3f, std::string, std::string, rclcpp::Time);
// void publish_body_odom(Sophus::SE3f, Eigen::Vector3f, Eigen::Vector3f, rclcpp::Time);
// void publish_kf_markers(std::vector<Sophus::SE3f>, rclcpp::Time);

// bool save_map_srv(const std::shared_ptr<orbslam3::srv::SaveMap::Request>,
//                   std::shared_ptr<orbslam3::srv::SaveMap::Response>);
// bool save_traj_srv(const std::shared_ptr<orbslam3::srv::SaveMap::Request>,
//                    std::shared_ptr<orbslam3::srv::SaveMap::Response>);

// cv::Mat SE3f_to_cvMat(Sophus::SE3f);
// tf2::Transform SE3f_to_tfTransform(Sophus::SE3f); // Updated to tf2::Transform for ROS 2
// sensor_msgs::msg::PointCloud2 mappoint_to_pointcloud(std::vector<ORB_SLAM3::MapPoint*>, rclcpp::Time);

#endif